《深入了解jvm虚拟机》笔记



JDK(Java Development kit)：包括Java程序设计语言、Java虚拟机、Java类库这三部分，JDK是用于支持JAVA程序开发的最小环境。

JRE(Java Runtime Environment): Java类库中JavaSEAPI子集和Java虚拟机，JRE是支持Java程序运行的最小环境。



Java的指令集架构：

栈：跨平台性、指令集小、指令多；执行性能比寄存器差。



Jvm的生命周期：

- 虚拟机的启动：通过引导类加载器创建一个初始类来完成的，这个类由虚拟机的具体实现指定。
- 虚拟机的执行：程序开始执行时它才开始执行，程序结束时它就停止。执行一个Java程序的时候，真正执行的是一个Java虚拟机的进程。
- 虚拟机的退出有几种情况：
  1. 程序正常结束
  2. 程序在执行过程中遇到异常或错误而异常终止
  3. 由于操作系统出现错误而导致虚拟机进程终止
  4. 某线程调用Runtime类或System类的exit()方法，或者Runtime类的half()方法，并且Java安全管理器也允许这次exit或half操作
  5. JNI规范描述了用JNI Invocation API来加载或卸载虚拟机时，java虚拟机的退出情况。



类的加载过程：

加载——>链接——>初始化

加载：

1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个二进制字节流所代表的静态存储结构化为方法区运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

初始化：

1. 初始化阶段是执行构造器方法<clinit>的过程
2. 此方法不需要定义，是javac编译器自动收集类中的所有类变量的幅值动作和静态代码块中的语句合并而来的
3. 构造器方法中的指令按语句在源文件中出现的顺序执行
4. <clinit>()不同于类的构造器。（关联：构造器是虚拟机下的<init>()）
5. 若该类有父类，虚拟机会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕
6. 虚拟机必须保证一个类的<clinit>()方法在多线程下已经被同步加锁



类的加载器：

JVM支持两种类型的类加载器，分别为引导类加载器和自定义类加载器

自定义类加载器：虚拟机将所有派生于抽象类ClassLoader的类加载器划分为自定义类加载器



类加载器的获取:

```Java
#获取系统类加载器
    ClassLoader  systemClassLoader = ClassLoader.getSystemClassLoader();

#获取扩展类加载器
    ClassLoader  extClassLoader = systemClassLoader.getParent();

#获取引导类加载器:获取不到
    ClassLoader bootStrapClassLoader = extClassLoader.getParent();

#获取用户自定义类的类加载器:默认使用系统类加载器进行加载
    ClassLoader classLoader = Text.Class.getClassLOader();

#获取String的类加载器:  Java的核心类库都是使用引导类加载器进行加载的
    ClassLoader classloader = String.Class.getClassLoader();
    
```



启动类加载器：

- 使用C++/C实现，嵌套在虚拟机内部
- 用来加载Java的核心类库
- 并不继承于Java.lang.ClassLoader，没有父类
- 加载拓展类加载器和用户自定义类加载器，并指定为它们的父类加载器
- 只加载java、javax、sun等开头的类



拓展类加载器：

- Java语言编写
- 派生于ClassLOader类
- 父类加载器为启动类加载器
- 从java.ext.dirs系统属性所指定的目录中加载类库，或从jdk安装的目录的jre/lib/ext子目录下加载类库，如果用户创建的JAR放在此目录下，也会自动由扩展类加载器进行加载



系统类加载器：

- java语言编写
- 派生于ClassLOader类
- 父类加载器为拓展类加载器
- 是程序默认的类加载器
- 负责加载环境变量ClassPath或系统属性Java.class.path指定路径下的类库



获取ClassLoader的途径：

```Java
#方式一：获取当前类的加载器   clazz为Class类的一个实例
clazz.getClassLoader()

#方式二：获当前线程上下文的类加载器
Thread.currentThread().getContextClassClassLoader();

#方式三：获取系统类加载器
ClassLoader.getClassLoader();

#方式四：获取调用者的类加载器
DriverManager.getCallerClassLoader();
```



双亲委派机制：

1. 如果一个类加载器收到加载请求，它并不会自己先去加载，而且把这个请求委托给父类的加载器去执行
2. 如果父类的加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终到达顶层的启动类加载器
3. 如果父类加载器可以完成类加载任务，则成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己加载



优势：

- 避免类的重复加载
- 保护程序安全，防止核心API被随意篡改



沙箱安全机制：

自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器会在加载过程中率先加载jdk自带的文件，（rt.jar包下java\lang\String.class），报错信息说没有main方法，就是因为加载的的是rt.jar包下的String类,这样可以保证对核心源代码的保护，这就是沙箱安全机制。



JVM中表示两个class对象是否是同一个类存在的两个必要条件：

- 类的完整类名必须完全一致，包括包名
- 加载这个类的类加载器（指ClassLoader实例对象）必须完全相同



JVM必须知道一个类是启动类加载器还是用户自定义类加载器加载的，如果一个类是由用户自定义类加载器加载的，那么JVM会将

这个类加载器的一个引用作为类型信息的一部分保存在方法区中



Java程序对类的使用方式：主动使用和被动使用

主动使用的七种情况：

1. 创建类的实例
2. 访问某个类或接口的静态变量，或对某个静态变量赋值
3. 调用类的静态方法
4. 反射
5. 初始化一个类的子类
6. Java虚拟机启动时被标明为启动类的类
7. JDK 7开始提供的动态语言支持



PC寄存器：

JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。

作用：用来存储指向下一条指令的地址，也是即将要执行的指令代码，由执行引擎读取下一条指令。

- 它是一块内存很小的空间。也是运行速度最快的存储区域
- 每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致
- 任何时间一个线程都只有一个方法在执行，也就是当前方法，程序计数器会存储当前线程正在执行的Java方法的JVM指令地址。如果执行的是native方法，则是未指定值（undefined)
- 没有GC回收，也没有内存溢出。



PC寄存器存储字节码指令地址的作用：CPU不停的切换线程，切换回来以后，就得知道从哪接着继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。



PC寄存器为什么会被设定为线程私有？CPU不停的做线程切换，必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，最好的方法是为每一个线程都分配一个PC寄存器。



虚拟机栈：

- 定义：每个线程在创建时都会创建一个虚拟机栈，其内部保存着一个个栈帧，对应着一次次的Java方法调用
- 生命周期和线程一样
- 主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回



栈中可能会出现的异常：JVM规范允许Java栈的大小要么是固定的要么是动态拓展的

- 如果采用固定大小的栈，线程创建时会选定虚拟机栈的大小，如果线程请求分配的栈容量超过虚拟机栈允许的最大容量，就会抛出StackOverFlowErrop的异常
- 如果虚拟机栈可以动态拓展，并且在尝试拓展时没有申请到足够的内存或者创建新的线程时没有足够的内存去创建对应的虚拟机栈，就会抛出OutOfMemoryError的异常



栈中存储什么？

栈中的数据都是以栈帧的格式存储的，在当前这个线程上正在执行的每个方法都各自对应着一个栈帧，栈帧是一个内存区块，是一个数据区域，维系着方法执行过程中的各种数据信息



Java方法两种返回函数的方式：无论哪种都会导致栈帧被抛出

1. 正常的函数返回 ，以return指令结束
2. 抛出异常



栈帧的内部结构：

1. 局部变量表
2. 操作数栈
3. 动态链接
4. 方法返回地址
5. 一些附加信息



局部变量表：

- 定义为方法参数，用来存储方法参数和方法体内的局部变量
- 不存在数据线程安全问题
- 所需要的容量大小是在编译期确定下来的，并且在运行期间不会改变大小
- 局部变量表中的变量只在当前方法调用中有用有效，方法调用结束，随着方法帧的销毁，局部变量表也随之销毁



局部变量表最基本的存储单元是变量槽（slot）

- 存放着编译期可知的各种基本数据类型、引用类型、返回地址类型的变量
- 32位以内的类型占用一个slot，64位类型（long、double）占用两个
- JVM会为每一个slot都分配一个索引，通过索引可以访问到局部变量表中指定的局部变量值
- 当一个实例方法被调用时，它的方法参数和局部变量会按照顺序被复制到每一个局部变量的slot上
- 如果当前帧是由构造方法或者实例方法创建的，该对象引用(this)会被存放在index=0的slot上，其余按顺序存放
- 栈帧中局部变量表的槽位是可以重复利用的，一个局部变量过了其作用域，在其作用域后申明的一个新的局部变量很有可能会复用这个过期局部变量的槽位，达到节省资源的目的



变量的分类：按照在类中的申明位置来划分

1. 成员变量：在使用前，都经过默认初始化赋值	

   - 类变量：连接的准备阶段：给类变量默认赋值；初始化阶段：显示赋值

   - 实例变量：随着对象的创建，会在堆空间中分配实例变量空间，进行默认化赋值

2. 局部变量：在使用前必须要经过显示赋值，否则，编译不通过。



栈帧中与性能调优关系最密切的局部变量表，局部变量表中的变量也是重要的垃圾回收根节点



操作数栈：

主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间

- 当一个方法开始执行时，一个栈帧会被创建出来，这个方法的操作数栈是空的
- 操作数栈的最大深度在编译器就已经定义好了
- 操作数栈不是根据访问索引的方式来进行数据访问而是根据入栈和出栈操作。
- 被调用的方法有返回值的话，其返回值会被压入当前栈帧的操作数栈中



动态链接：每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用

作用：将常量池中的符号引用转换为调用方法的直接引用



静态链接：被调用的方法在编译期可知，且运行期保持不变，这种情况下将调用方法的符号引用转变为直接引用的过程

动态链接：被调用的方法在编译期无法确定下来，只有在程序运行期间才能将符号引用转变为直接引用



非虚方法：静态方法、私有方法、final方法、构造器方法、父类方法

子类多态性的使用前提：类的继承关系    方法的重写





方法返回地址：存放调用该方法的PC寄存器的值

- 在方法退出后都返回到该方法被调用的地址，方法正常退出时，被调用者的PC计数器的值作为返回地址，也是调用该方法的指令的下一条指令的地址；异常退出的，返回地址通过异常表来确定，异常退出不会给它的上层调用者产生任何返回值

- 正常完成出口：执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者

- 返回指令需要根据方法返回值的实际类型来定：ireturn(返回值是boolean、byte、short、int、)，lreturn，dreturn,freturn,areturn; return指令供声明为void、实例初始化方法、类和接口初始化方法使用

- 方法执行过程中抛出异常时的异常处理，存储在异常处理表中，方便在发生异常时找到处理异常的代码

- 本质上方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器的值。让调用者方法继续执行下去



本地方法栈：管理本地方法的调用

- 也是线程私有的
- 允许实现成固定或可动态拓展的内存大小
- 本地方法使用C语言实现的
- 具体做法是在本地方法栈中登记本地方法，在执行引擎执行时加载本地方法库



堆：

- 每个JVM实例对应一个堆内存，堆是Java内存管理的核心区域
- 堆区在JVM启动时被创建，空间大小也被创建了，是JVM管理的最大一块内存空间，堆大小是可以调节的
- 堆可以在物理上是不连续的内存空间，在逻辑上它被视为连续的
- 所有线程共享Java堆，但可以划分线程私有的缓存区
- 所有对象实例和数组都在运行时分配在堆上
- 数组和对象永远不会存储在栈上，在栈帧中保存引用，这个引用指向对象或数组在堆中的位置
- 方法结束后，堆中的对象不会马上被移除，而是在GC时才会被移除
- 堆，是垃圾回收的重点区域



内存细分：

现代垃圾回收器大部分基于分代收集理论

- JDK7及以前细分为新生代、老年代p、永久区
- JDK8以后细分为新生代、老年代、元空间



设置堆空间的大小：

- -Xms设置堆空间（新生代+老年代）的初始内存大小   -X是JVM的运行参数  ms是memory start的缩写
- -Xmx设置堆空间（新生代+老年代）的最大内存大小



默认堆空间大得大小：

初始内存大小：电脑物理内存大小/64

最大内存大小：电脑物理内存大小/4



```
#返回虚拟机中堆的初始内存
long initialMemory = Runtime.getRuntime.totalMemory();

#返回虚拟机中堆的最大内存
long maxMemory = Runtime.getRuntime.maxMemory();
```



存储在JVM中的对象可以分为两类：

- 一类生命周期短，这类对象的创建和消亡都非常迅速
- 另外一类对象的生命周期非常长，极端情况下可以与JVM的生命周期保持一致



新生代细分为Eden区、survivor0区和survivor1区

- -XX: NewRadio:设置新生代与老年代的比例，默认值是1:2

- -XX:SurvivorRadio:设置新生代中Eden区与Survivor区的比例，默认是8:1:1
- 几乎所有的Java对象都是Eden区new出来的
- 绝大多数的对象消亡在新生代中



对象分配过程：

1. new的对象先放在伊甸区。此区有大小限制
2. 当伊甸区满的时候，程序又需要创建新对象，垃圾回收器对伊甸区进行垃圾回收，将伊甸区不再被其他对象引用的对象销毁，再加载新的对象到伊甸区
3. 然后将伊甸区的剩余对象移动到幸存者0区
4. 如果再次触发垃圾回收，上次存放在幸存者0区的的，没有被回收，会被移到到幸存者1区
5. 如果再次经历垃圾回收，此时会重新放回0区，接着再去一区
6. 什么时候可以去老年代呢？可以设置次数，默认是15

总结：针对幸存者0区、1区，复制之后有交换，谁空谁是to

关于垃圾回收，频繁发生在新生区收集，很少在养老区收集，几乎不会在元空间收集



GC按照回收区域分为两大类：一种是部分收集(partial gc)，一种是整堆收集(full gc)

- 部分收集：不是完整的收集整个java堆的垃圾收集
  1. 新生代收集(minor gc)：只是新生代的垃圾收集
  2. 老年代收集(major gc):只是老年代的垃圾收集    只有CMS GC会有单独收集老年代的行为
  3. 混合收集(mixed GC)：收集整个新生代和部分老年代的垃圾收集   只有G1 GC会有这种行为
- 整堆收集(full GC): 收集整个Java堆和方法区的垃圾收集



年轻代GC的触发机制：

- 当Eden区满的时候触发，survivor区满的时候不会触发
- 大多Java对象具备朝生夕死的特性，minor GC非常频繁，而且回收速度很快
- minor GC会引发STW,暂停其它线程，等垃圾回收结束，用户线程才恢复运行



老年代GC的触发机制：

- 指发生在老年代，对象从老年代消失时，我们说major Gc或full Gc发生了

- 出现major Gc,经常伴随着至少一次的minor GC
- major Gc速度比minor Gc速度慢上10倍以上
- 如果major GC之后，内存还不足，就报OOM了



full GC触发机制：

- 调用system.gc()时
- 老年代空间不足
- 方法区空间不足
- 通过minor gc进入老年代的平均大小大于老年代的可用内存
- 由eden区、幸存者from区向幸存者to区复制时，对象大小大于to空间可用内存，则把该对象转到老年代，且老年代可用内存也小于该对象时



空间分配策略：

- 优先分配到Eden
- 大对象直接分配到老年代 尽量避免程序中出现过多的大对象
- 长期存活的对象分配到老年代
- 动态年龄判断    如果幸存者区中相同年龄的所有对象大小的总和大于幸存者区的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到达到阈值
- 空间分配担保



为什么有TLAB？对象创建实例的过程在JVM中十分频繁，并发环境下从堆中划分内存环境是线程不安全的，为了避免多个线程操作同一个地址，需要使用加锁机制，进而影响分配速度



什么是TLAB？

- 从内存分配而不是垃圾收集的角度，对eden区域继续划分，JVM为每一个线程分配了一个私有缓存区域
- 多线程分配内存区域时，使用TLAB避免类一系列线程不安全问题，同时还能提升内存分配的吞吐量
- JVM将TLAB当做内存分配的首选,可以通过参数: -XX:useTLAB设置是否开启TLAB
- TLAB展Eden空间的1%,参数: -XX:TLABWasteTargetPercent改变占eden空间的大小
- 一旦对象在TLAB空间内存分配失败，JVM就会尝试加锁机制保证数据操作的原子性，直接在Eden空间分配内存



方法区是一块独立于Java堆的内存空间

- 方法区与堆一样，是各个线程共享的区域
- 在JVM启动时被创建，实际的物理内存空间是不连续的
- 方法区的的大小，可以设置为固定大小或者可拓展的
- 方法区的大小决定系统可以保存多少个类，如果系统保存了太多的类，可能会出现方法区溢出，抛出OOM的错误，比如加载太多第三方的jar包，Tomcat部署的工程过多，大量动态生成反射类
- 关闭JVM就会释放这个区域的内存



方法区的演进：

- JDK8 ，废弃了永久代的概念，改用使用本地内存的元空间来代替
- 元空间本质与永久代一样。都是虚拟机方法区的实现，最大的区别是：元空间不是使用设置在虚拟机中的内存，而是使用的本地内存
- 不仅名字变了，具体结构也变了
- 如果方法区无法满足新的内存分配需求时，将抛出OOM异常



方法区的内存：

- JDK7以前： -XX：PermSize设置初始永久代空间，默认是20.75M    -XX:MaxPermSize来设定永久代最大可分配空间，32位机器默认64M,64位机器默认82M，当加载的类信息超过这个限制，就会抛出OOM
- JDK8以后， 使用参数-XX:MetaSpaceSize和-XX:MaxMetaSpaceSize来指定
  1.  	window下。默认初始内存是21M,最大内存值时-1，没有限制
  2. 与永久代不同，不指定大小情况下，虚拟机会耗尽所有可用的系统内存，如果元空间发生溢出，会抛出OOM
  3. 初始元空间大小为21M，一旦触及这个初始的高水位先，会触发full GC卸载没用的类，然后高水位线会被重置提高。释放的元空间空间不足，在低于最大值的情况下，会提高，释放的元空间过多，会降低
  4. 为了避免频繁的触发full GC，会将初始水平线设置为一个较高的值



方法区存储的内容：类型信息、常量、静态变量、即时编译器编译后的代码缓存



常量池：可以看做一张表，虚拟机指令根据这张表找到要执行的类名、方法名、参数类型、字面量等类型



运行时常量池：

- 是方法区的一部分
- 常量池表用于存储编译期生成的各种字面量和符号引用，在类加载后存放到方法区的运行时常量池中
- 常量池中的数据项像数组项一样，通过索引访问
- 运行时常量池中包含的不同常量，不是常量池中的符号地址，运行时转换为真实地址
- 具备动态性 String.intern()



方法区的变化：

- JDK6以前，有永久代，静态变量存放在永久代上

- JDK7 有永久代，但逐渐去除永久代，字符串常量、静态变量移除，保存在堆中
- JDK 8 无永久代，类型信息、属性信息、方法信息、运行时常量池保存在本地内存的元空间中，字符串常量、静态变量保存在堆中



StringTable 为什么要调整：

jdk7将字符串常量放到堆中，因为永久代回收效率低，只有触发full Gc才回收。full Gc只有老年代空间不足、永久代空间不足才会发生，StringTable回收效率低，而开发中有大量的字符串被创建，回收效率低，导致永久代内存不足，放到堆里，能及时回收内存



方法区的垃圾回收主要回收两类内容：常量池中废弃的常量和不再使用的类型

- 常量池的回收策略：只要常量池中的常量没有被任何地方引用就回收
- 方法区的回收效果比较难让人满意，尤其是类型的卸载，条件什么苛刻



创建对象的六个步骤：

1. 判断对象的类是否加载、链接、初始化			
   - 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在元空间常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析、初始化（即判断类元信息是否存在)，如果没有，在双亲委派机制下，使用当前类加载器以ClassLoader+包名+类名为关键字查找对应的Class文件，找到则进行类加载，并生成对应的Class对象，没有找到，则抛出ClassNotFoundException的异常
2. 为对象分配内存
   - 首先计算对象占用空间大小，接着在堆空间中划分一块内存给新对象，如果实例成员变量是引用变量，仅分配引用变量空间即可，4个字节
   - 如果堆空间内存规整，采用指针碰撞法划分内存；如果内存不规整，虚拟机需要维护一个列表，通过空闲列表来分配
3. 处理并发安全问题
   - 采用CAS失败重试、区域加锁保证更新的原子性
   - 每个线程预先分配一块TLAB
4. 初始化分配到的空间
   - 所有属性设置默认值，保证对象实例属性不赋值时可以使用
5. 设置对象的对象头
   - 将对象的类信息、对象的HashCode值和对象的GC信息、锁信息存放在对象的对象头中
6. 执行init方法进行初始化



对象的内存布局：

1. 对象头
   - 运行时元数据：哈希值、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳
   - 类型指针：指向类元数据，确定该对象所属的类型
2. 实例数据
   - 是对象真正存储的有效信息，包括代码内定义的各个属性
   - 规则：相同宽度的属性总被分配在一起，父类中定义的变量总会出现在子类之前，子类的窄变量可能会插入父类变量的空戳
3. 对齐填充：起到占位符的作用



对象的访问定位：JVM是如何通过栈帧上的对象引用访问到其内部的对象实例呢？通过栈上的引用访问

- 对象访问主要有两种方式：
  - 句柄访问：栈上的引用地址指向句柄池中的句柄，句柄包含到对象实例数据的指针，到对象类型数据的指针，可以通过这在堆中访问到对象的实例信息，在方法区中访问到对象的类型信息
  - 直接指针：栈上的引用地址直接指向堆中的对象实体，对象实例中也保存着到对象类型数据的指针，也可以访问到对象类型信息



直接内存：

- 是Java堆外的、直接向系统内存申请的空间
- 来源于NIO，通过堆中的DirectByteBuffer操作Native内存
- 访问直接内存速度优于Java堆
- 也会抛出OOM异常
- 不受限于堆的大小，受限于操作系统的内存大小
- 缺点：分配回收的成本较高、不受虚拟机内存回收管理
- 内存大小可以通过MaxDirectMemroySize设定
- 默认情况下，与堆大小一致



Java代码解释和编译运行的过程：

程序源码     语法分析   单词流	语法分析	抽象语法树

- 指令流	解释器 解释运行
- 优化器    中间代码   生成器  目标代码



String的基本特性：

```
#字面量定义方式
String s1 = "hello";
#new操作符
String s2 = new String("hello");
```

- String声明为final的，是不可变的
- 支持序列化、可以比较大小
- jdk8以前底层是char[]，jdk9以后是byte[]



字符串的常量池中是不会存储相同内容的字符串的

- String的String Pool是一个固定大小的Hashtable，默认值大小长度是1009，如果放进String Pool的字符串特别多，就会造成hash冲突，导致链表过长，性能下降
- -XX：StringTableSize可设置StringTable的长度
- jdk6默认长度是1009，jdk7以后默认值是60013,可设置的最小长度是1009



字符串常量池的位置在堆中



什么是垃圾？

- 指运行程序中没有任何指针指向的对象
- 如果没有及时清理内存中的垃圾，垃圾对象占用的空间会保留到应用程序结束，被保留的空间无法被其他对象所使用，可能导致内存溢出



自动垃圾回收降低了内存泄漏和内存溢出的风险



垃圾标记阶段：执行垃圾回收之前，需要区分内存中哪些是已经死亡的对象，哪些是存活对象，判断对象存活有两种方式：引用计数算法和可达性分析算法



引用计数算法：

- 为每一个对象保存一个整型的引用计数器属性，记录对象的引用情况
- 对于一个对象，如果任意一个对象引用了它，引用计数器就加一；引用失效就减一，只要对象的引用计数器的值为0，就进行回收
- 最大的缺陷是无法处理循环引用的问题，所有Java回收算法中没有采用它



可达性分析算法：

- Gc Roots根集合是一组活跃的引用
- 以根集合为起始点。按照从上到下的方式搜索被根集合连接的目标对象是否可达
- 使用可达性分析算法以后，所有存活的对象都会被根集合直接活间接的连接，搜索所走过的路径称为引用链
- 如果目标对象没有任何引用链相连，则是不可达的，意味着该对象已经死亡，可以标记为垃圾对象
- 可达性分析算法中，只有能够被根对象集合直接或间接连接的对象才是存活对象



GC Root包含的几类元素：

- 虚拟机栈中引用的对象
- 本地方法栈中JNI引用的对象
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁synchronized持有的对象
- 虚拟机内部的引用
- 反映虚拟机内部情况的JMXBean、JVMTI注册中的回调、本地代码缓存等
- 还可能根据用户选择的垃圾回收器以及当前回收的内存区域的不同，将其他对象加入根对象集合。比如分代收集和局部回收



对象的finalization机制：Java语言提供finalization对象终止机制允许开发人员提供对象被销毁之前的自定义处理逻辑

- 当垃圾回收器发现没有任何引用指向一个对象，在垃圾回收这个对象之前会调用这个对象的finalize方法
- finalize方法允许在子类中被重写，用于对象被回收时进行资源回收工作
- 永远不要主动的调用对象的finalize方法，应该交给垃圾回收机制调用



虚拟机中的对象存在三种状态：

1. 可触及的：根结点可到达的
2. 可复活的：可能在finalize中复活的，与引用链上的任一对象建立了联系
3. 不可触及的：finalize被调用但没有复活的



标记——清除算法：

- Collection从引用根结点开始遍历，标记所有被引用的对象，在对象的头里记录为可达对象
- 清除：Collection从堆内存从头到尾进行线性的遍历，如果发现某个对象header中没有被标记为可达对象，就清除
- 缺点：容易产生空闲碎片；效率不高；用户体验差



复制算法：

- 将活着的空间分为两块，每次只使用一块，在垃圾回收时将使用中的存活对象复制到另一块未使用的空间中，然后清除正在使用的内存块中的所有对象，交换两个内存中的角色，最后完成垃圾回收
- 优点：没有清除和标记过程，运行高效；不会出现碎片问题
- 缺点：需要两倍的内存空间；需要GC维护区域之间的对象引用关系



标记——压缩算法：

- 从根结点开始标记所有被引用的对象
- 将所有存活对象压缩到内存的另一端，按顺序排放，然后清除边界外所有的内存空间



分代收集算法：

- 不同生命周期的对象采用不同的收集方式，以便提高收集效率
- 年轻代区域小，对象生命周期短，回收频繁，采用复制算法
- 老年代区域大，生命周期长，回收没有年轻代频繁，采用标记-清除或标记-压缩算法



增量收集算法：

- 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，可以让垃圾回收线程和用户线程交替执行，每次垃圾回收只收集一小片内存空间，接着切换到应用程序线程，依次反复，直到垃圾收集完成
- 通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的形式完成标记、清理、复制工作。
- 系统开销大



分区算法：

- 为了更好的控制Gc的停顿时间，将一个大的内存空间分割成许多小块，根据目标的停顿时间，每次合理的回收若干个小空间，而不是整个堆空间，从而减少一次GC的停顿时间



内存溢出：没有空闲内存，并且垃圾回收器也无法提供更多的内存

- 虚拟机的堆内存设置不够
- 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集



内存泄漏：只有对象不会再被程序用到了，但是Gc又不能回收他们的情况，才叫内存泄漏

- 单例模式：单例的生命周期和应用程序一样长，所以，如果持有外部对象的引用的话，那么这个外部对象是不可回收的，会导致内存泄漏的产生
- 一些提供close的资源未关闭导致内存泄漏，数据库连接、网络连接、io必须手动close，否则是不能被回收的



STW:指Gc事件发生过程中，会产生应用程序的停顿，停顿产生时整个应用程序线程都会被暂停，没有任何响应

- 频繁中断会让用户感觉是网速不快造成的，所以我们需要减少STW的发生



垃圾回收的并发与并行：

- 并行：多条垃圾回收线程并行工作，但此时用户线程处于等待状态 如ParNew、Parallel Scavenge、Parallel Old;
- 并发：用户线程与垃圾回收线程同时执行，垃圾回收线程在执行时不会停顿用户线程的运行



安全点：程序执行时只有在特定的位置停下来才开始GC，这些位置称为安全点

- 安全点的选择很重要，太频繁导致运行时性能问题，太少导致Gc等待的时间太长
- 抢先式中断：首先中断所有线程，如果还有线程不在安全点，就恢复线程，让线程跑到安全点
- 主动式中断：设置一个中断标志，各个线程运行到安全点的时候主动轮询这个标志，如果中断标志为真，则将自己主动挂起



安全区域：一段代码片段中，对象的引用关系不会发生变化，在这个区域中任何位置开始Gc都是安全的



强引用：程序代码之中普遍存在的引用赋值，无论任何情况下，只有强引用关系还在，垃圾回收器永远不会回收掉被引用的对象

- 默认的引用类型
- 强引用时内存泄漏的主要原因之一
- 可以直接访问对象



软引用：垃圾回收之时，会把这些对象列入垃圾回收范围，内存不足即回收

- 内存足够时，不会回收可达的软引用，不够时，会回收
- 描述高速缓存





弱引用：垃圾回收时，肯定会被回收掉，发现即回收

- 不同：Gc在回收时，需要通过算法检查是否回收软引用对象，对于弱引用对象，发现即回收



虚引用：对对象毫无影响，唯一的目的是能在这个对象被收集器回收时收到一个系统通知。

- 跟踪垃圾回收过程



终结器引用：用以实现对象的finalize方法



评论Gc性能的指标：

- 吞吐量：运行用户代码的时间占总运行时间的比例
- 垃圾收集开销：垃圾收集时间栈总运行时间的比例
- 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间
- 收集频率：收集操作发生的频率
- 内存占用：堆占用系统内存的大小
- 快速：一个对象从诞生到被回收所经历的时间



新生代收集器：

- serial  、  parnew 、   parallel  scavenge



老年代收集器:

- serial old 、 Parallel old、cms



整堆收集器：G1





serial垃圾回收器：

- 采用复制算法，串行回收、和STW机制执行垃圾回收
- serial old收集器也采用串行回收、stw，不过内存回收算法是标记压缩算法，是虚拟机32位client模式下默认的老年代回收器，在64位server模式下是老年代cms收集器的备用方案，与Parallel scanvengr回收器配合使用
- 串行回收：只使用一条线程去执行垃圾回收，并且在执行时会挂机用户线程，直到它收集完成
- 参数;-XX:+useSerialGc参数可以指定使用serial和serial old收集器



ParNew回收器：

- 采用复制算法、并行回收、stw机制
- 很多虚拟机servel模式下的新生代的默认收集器
- 对于新生代，垃圾回收频繁，使用并行方式高效；对于老年代，回收次数少，使用串行方式节省资源（省去切换线程的开销）
- 参数：-XX:+UseParNewGc指定使用收集器， -XX：ParallelGcThread限制线程数量，默认开启和CPU数据相同的线程数



Parallel Scanvenge收集器：

- 采用复制算法、并行回收、stw
- 收集器目标是达到一个可控制的吞吐量，遵循吞吐量优先的原则
- 自适应策略
- 高吞吐量适合后台运用而不需要太多交互时间的任务
- parallel old收集器采用标记压缩算法、基于并行回收和stw，用于老年代回收
- 参数配置：-XX:+UseParallelGc 指定年轻代使用Parallel收集器    -XX:+UseParallelOldGc 指定老年代使用ParallelOldGc收集器，  两者可以互相激活 ，jdk8默认使用者两收集器
- -XX:ParallelGcThreads  设置年轻代并行收集器的线程数，一般的默认线程数与cpu数相等，cpu数量小于8时。
- -XX:MaxGcPauseMils 设置垃圾回收器最大停顿时间，stw时间，单位是毫秒
- -XX:GcTimeRadio 设置垃圾收集开销
- -XX: +UseAdapttiveSizePolicy 设置收集器具有自适应策略，年轻代、老年代、Eden区、survivor的大小会自动调节，达到堆大小、吞吐量、停顿时间之间的平衡



CMS虚拟机：

- 第一款真正意义上的虚拟机，实现了垃圾回收线程和用户线程同时工作
- 关注点是尽可能缩短垃圾收集时用户线程的停顿时间
- 在老年代进行垃圾收集，采用标记-清除算法，也有stw机制



CMS垃圾回收过程：

- 初始标记阶段：stw机制，标记出Gc root能直接关联到的对象，然后恢复用户线程
- 并发标记阶段：遍历整个对象图，耗时较长但不需要挂起用户线程
- 重新标记：修正并发标记期间，因程序运作而导致标记产生变动的对象的标记
- 并发清除阶段：清理标记阶段判断已经死亡的对象，释放空间



CMS垃圾回收的优点和缺点：

- 最耗时的并发标记和并发收集都不需要停顿用户线程，所以整体是低停顿的

- 在cms垃圾收集过程中，应确保应用程序线程有足够的内存可用，所以应该在堆内存的使用率达到一个阈值，就应该开始垃圾回收。要是cms过程间预留的内存无法满足程序需要，虚拟机将会采用后备方案，启用serial  old 收集器，停顿时间变长

- 会产生内存碎片。采用标记-清除算法

- cms收集器对cpu资源敏感，可能会降低用户线程执行效率

- 无法处理浮动垃圾

- 参数：-XX:UseConcMarkSweepGc  手动指定使用cms ，会激活年轻代收集器ParNew 

  

G1收集器：

- 设定目标：延迟可控的条件下，获得尽可能高的吞吐量



G1收集器的优势：

- 并发与并行：并行，回收期间有多个Gc线程同时工作，此时用户线程stw;并发:拥有与用户线程交替执行的能力
- 分代收集：区分年轻代、老年代；将堆分成多个区域，包含了逻辑上的年轻代和老年代；兼顾年轻代和老年代
- 空间整合：内存和回收一区域为单位，尽管区域之间是复制算法，但是实际上看做标记压缩算法
- 可预测的停顿时间模型
- 缺点：额外的内存负载



区域：

- G1将堆划分我2048个区域，每个区域的大小根据堆空间实际大小而定。
- 所有的区域大小相同，在虚拟机的生命周期内不会改变
- H区用来存大对象，超过1.5区域大小就存到H区



G1回收器回收过程：

- 年轻代GC: 当年轻代的eden区用尽时开始年轻代回收过程，年轻代收集过程是一个并行的独占过程，会暂停所有用户线程，把年轻代区间存活对象移survivor区或老年代
- 当堆内存到达45阈值时，开始老年代并发标记过程
- 标记完成开始混合回收，不需要整个老年代被回收，一次只需要回收一部分。同时，年轻代和老年代是一起回收的



记忆集：

- 每个区域都有一个记忆集
- 每个引用类型数据写操作时，产生一个写屏障暂时中断操作
- 检查要写入的引用对象是否和该引用类型数据是否在同一个区域
- 如果不同，用卡表把相关引用信息记录到引用指向对象所在的记忆集中
- 当垃圾收集时，在Gc Root的枚举范围内加入记忆集，就可以保证不用全局扫描，也不会有遗漏

