进程三种基本状态：

- 运行态：占用cpu，并在cpu上运行

- 就绪态：已经具备运行条件，但由于没有空闲的cpu，而暂时不能运行（系统已经拥有除处理机以外的所有需要资源，一旦获得cpu，就开始运行）
- 阻塞态：因等待某一事件而不能运行（比如等待打印机工作，cpu是系统中最宝贵的资源，为了提高cpu的使用率，需要先将进程需要的资源分配到位，才能得到cpu的服务）

另外两种状态：

- 创建态：进程正在被创建，系统为其分配资源、初始化pcb
- 终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销pcb



进程状态的转换：

<img src="C:\Users\hello\Desktop\图片\进程状态转换.jpg" alt="进程状态转换" style="zoom: 67%;" />





进程通信：

- 进程之间的信息交换
- 共享存储：
  1. 两个进程对共享空间的访问必须是互斥的
  2. 基于数据结构的共享：速度慢、限制多、低级通信
  3. 基于存储区的共享：速度快、高级通信
- 管道通信：
  1. 管道是连接读写进程的一个共享文件，实质是在内存中开辟了一个固定大小的缓冲区
  2. 只能采用半双工通信，各进程互斥的访问管道
- 消息传递：
  1. 进程间的数据交换以格式化消息为单位，通过操作系统提供的  发送消息、接收消息两个原语进行数据交换
  2. 直接通信：消息直接挂到接收进程的消息缓冲队列上
  3. 间接通信：消息先发到中间实体



线程的实现方式：

- 用户级线程：由应用程序通过线程库实现，线程管理工作由应用程序负责，线程切换在用户态下就可以完成
- 内核级线程：线程的管理由操作系统内核完成，所有的工作都由内核负责，内核级线程的切换需要在内核态下完成
- 可以将n个用户级线程映射到m个内核级线程上(n>m)，只有内核级线程才是处理机分配的单位



多线程模型：

- 多对一模型：多个用户级线程映射到一个内核级线程上，每个用户级线程只对应一个内核级线程
  - 优点：线程切换在用户空间进行即可，线程管理开销小、效率高
  - 缺点：当一个用户级线程被阻塞以后，内核级线程也被阻塞，并发度不高，多个线程不可在多核处理机上运行
- 一对一模型：一个用户级线程映射到一个内核级线程上，每个用户进程拥有与用户级线程一样多的内核级线程、
  - 优点：当一个线程被阻塞后，其它线程还能继续执行，并发度高。多线程可以在多核处理机上运行
  - 缺点：线程切换由操作系统内核完成，需要切换到核心态，线程管理的成本大、开销高
- 多对多模型：n个用户级线程映射到m个内核级线程上(n>m)
  - 克服了多对一并发度不高的缺点，也克服了一对一模型中一个用户进程占用多个内核级线程、开销太大的缺点



高级调度：

- 从外存中处于后备队列的作业中挑选一个，给它们分配内存资源，并建立相应的pcb,使得它们获得竞争处理机的权利
- 是外存和内存之间的调度，作业调入时会建立相应的pcb，调出时才撤销pcb
- 高级调度是指调入的问题，只有调入的时机需要由操作系统来决定，调出的时机是作业运行结束才调出
- 无——创建态——就绪态



中级调度：

- 引入虚拟内存技术，将暂时不能运行的进程调至外存等待，等其重新具备运行条件且内存空闲时，再调入内存运行
- 提高内存利用率和系统吞吐量
- pcb不会调至外存
- 中级调度决定哪个处于挂起状态的进程重新调入内存
- 挂起态——就绪态



低级调度：

- 按照某种方法或策略从就绪队列中选取一个进程，将处理机分配给它
- 是最基本的调度方式，频率很高
- 就绪态——运行态



进程调度的时机：

- 需要进行进程调度、切换的时机：
  1. 当前进程主动放弃处理机：进程正常终止、运行过程中发生异常而终止、经常主动请求阻塞(等待io)
  2. 被动放弃处理机：分给进程的时间片用完、有更紧急的事要处理、有更高优先级的进程进入就绪队列
- 不能进行进程调度、切换的时机：
  1. 处理中断的过程
  2. 进程在操作系统内核临界区中
  3. 在原子操作过程中



进程调度方式：

- 非剥夺调度方式：只允进程主动放弃处理机，即使有更紧急的任务到达，当前进程依旧使用处理机，直至进程结束或主动要求进入阻塞态，适用于早期的批处理系统
- 剥夺调度方式：当一个进程子处理机上运行，有更高优先级或紧迫的进程要求使用处理机时，则立即暂停正在执行的进程，将处理机分配给更重要急迫的进程，适合于分时处理系统和实时处理系统



进程切换的过程：

- 对原来运行进程各种数据的保存
- 对新的进程各种数据的恢复
- 进程切换是有代价的





