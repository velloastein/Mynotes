抽象类与接口

-多重继承



策略模式：

-定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的用户。

-面对的问题：一个超类有许多继承它的实现子类，子类之间有许多相同的属性和方法，也有许多不同的属性和方法。如果仅使用类继承的话，子类中不同的属性也会继承。仅使用把超类作为一个借口，子类作为它的实现类的话，代码复用太少。所以需要将超类中变化的和不变的分离，不变的使用类继承，变化的使用接口实现。

-在策略模式中，就是将子类中的变化的封装成接口，根据需要实现这个接口的实现类对象，在超类中定义一个属性类型为接口类型，不同的子类实现就调用这个属性的实现类对象去实现。还可以使用set方法动态修改属性，也就是修改实现类对象。



观察者模式：

-在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新。

-面对的问题：为交互对象之间的松耦合设计而努力。



装饰者模式：

-动态的将责任附加到对象上，想要拓展功能，装饰者提供有别于继承的另一种选择

-面对的问题：避免对象的继承滥用，使用对象组合的方式，做到运行时装饰。

​				首先是设计的类太多，维护困难（修改困难），其次违反开闭原则和分离原则。

-装饰者和被装饰者需要拥有共同的超类，因为多次装饰要求装饰者能够取代被装饰者



工厂模式方法：

- 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类



抽象工厂模式：

- 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

- 抽象工厂的方法经常以工厂方法的方式实现。抽象工厂的任务是定义一个负责创建一组产品的接口。这个接口内的每个方法都负责创建一个具体产品，同时我们利用实现抽象工厂的子类来提供这些具体的做法。



单件模式：

- 确保一个类只有一个实例，并提供全局访问点
- 需要私有的构造器、一个静态变量、一个静态方法
- 使用多个类加载器，可能导致单件失效而产生多个实例

适配器模式

- 将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。